'''
游戏规则背景

这是一个经典的“重力下落”算法练习题：

游戏面板是一个 nxn 的二维数组 board。

数字代表不同类型的方块, 0 表示空格（已被消除）。

当方块消除后，所有非空方块应该在“重力”作用下，向下移动，直至落到底部或其他方块之上。

空格 (0) 最终会集中在每一列的顶部。



题目要求

实现一个 applyGravity(board) 函数，需满足：

原地修改 board 二维数组，不允许创建新数组（原地操作）。

按列独立处理：对每一列单独进行重力下落操作。

保持非零方块的相对顺序不变。

将所有 0 移动至该列顶部。



示例说明

假设输入如下：

board = [
  [1, 2, 5, 4],
  [1, 3, 0, 5],
  [0, 0, 0, 0],
  [3, 1, 0, 2]
]


执行 applyGravity(board) 后结果变为：

[
  [0, 0, 0, 0],  // 顶部空格
  [1, 2, 0, 4],
  [1, 3, 0, 5],
  [3, 1, 5, 2]   // 非零方块下沉到底部
]


具体每列变化如下：

第 1 列：[1, 1, 0, 3] → [0, 1, 1, 3]

第 2 列：[2, 3, 0, 1] → [0, 2, 3, 1]

第 3 列：[5, 0, 0, 0] → [0, 0, 0, 5]

第 4 列：[4, 5, 0, 2] → [0, 4, 5, 2]



解题思路

双指针技巧 (类似 Move Zeroes)
可以借鉴 Move Zeroes 中常用的快慢指针技巧
'''

def applyGravity(board):
    rows, cols = len(board), len(board[0])
    for col in range(cols):
        l = rows - 1
        for r in range(rows - 1, -1, -1):
            if board[r][col] != 0:
                if l != r:  # 避免无意义的自交换
                    board[l][col], board[r][col] = board[r][col], board[l][col]
                l -= 1
    return board
